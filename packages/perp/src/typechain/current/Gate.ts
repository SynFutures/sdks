/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export type PendingStruct = {
  timestamp: BigNumberish;
  native: boolean;
  amount: BigNumberish;
  exemption: BigNumberish;
};

export type PendingStructOutput = [number, boolean, BigNumber, BigNumber] & {
  timestamp: number;
  native: boolean;
  amount: BigNumber;
  exemption: BigNumber;
};

export type FundFlowStruct = { totalIn: BigNumberish; totalOut: BigNumberish };

export type FundFlowStructOutput = [BigNumber, BigNumber] & {
  totalIn: BigNumber;
  totalOut: BigNumber;
};

export type RangeStruct = {
  liquidity: BigNumberish;
  entryFeeIndex: BigNumberish;
  balance: BigNumberish;
  sqrtEntryPX96: BigNumberish;
};

export type RangeStructOutput = [BigNumber, BigNumber, BigNumber, BigNumber] & {
  liquidity: BigNumber;
  entryFeeIndex: BigNumber;
  balance: BigNumber;
  sqrtEntryPX96: BigNumber;
};

export interface GateInterface extends utils.Interface {
  functions: {
    "allInstruments(uint256)": FunctionFragment;
    "allInstrumentsLength()": FunctionFragment;
    "config()": FunctionFragment;
    "deposit(bytes32)": FunctionFragment;
    "depositFor(address,bytes32)": FunctionFragment;
    "fundFlowOf(address,address)": FunctionFragment;
    "gather(address,address,uint32,uint256)": FunctionFragment;
    "getAllInstruments()": FunctionFragment;
    "handler()": FunctionFragment;
    "indexOf(address)": FunctionFragment;
    "initialize()": FunctionFragment;
    "instrumentInitData()": FunctionFragment;
    "isBlacklisted(address)": FunctionFragment;
    "launch(string,address,bytes,bytes32[2])": FunctionFragment;
    "pendingDuration()": FunctionFragment;
    "pendingOf(address,address)": FunctionFragment;
    "release(address,address)": FunctionFragment;
    "reserveOf(address,address)": FunctionFragment;
    "scatter(address,address,uint32,uint256)": FunctionFragment;
    "setBlacklist(address,bool)": FunctionFragment;
    "setPendingDuration(uint256)": FunctionFragment;
    "setThreshold(address,uint256)": FunctionFragment;
    "thresholdOf(address)": FunctionFragment;
    "weth()": FunctionFragment;
    "withdraw(bytes32)": FunctionFragment;
    "withdrawFor(address,bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "allInstruments"
      | "allInstrumentsLength"
      | "config"
      | "deposit"
      | "depositFor"
      | "fundFlowOf"
      | "gather"
      | "getAllInstruments"
      | "handler"
      | "indexOf"
      | "initialize"
      | "instrumentInitData"
      | "isBlacklisted"
      | "launch"
      | "pendingDuration"
      | "pendingOf"
      | "release"
      | "reserveOf"
      | "scatter"
      | "setBlacklist"
      | "setPendingDuration"
      | "setThreshold"
      | "thresholdOf"
      | "weth"
      | "withdraw"
      | "withdrawFor"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "allInstruments",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "allInstrumentsLength",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "config", values?: undefined): string;
  encodeFunctionData(functionFragment: "deposit", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "depositFor",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fundFlowOf",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "gather",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllInstruments",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "handler", values?: undefined): string;
  encodeFunctionData(functionFragment: "indexOf", values: [string]): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "instrumentInitData",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isBlacklisted",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "launch",
    values: [string, string, BytesLike, [BytesLike, BytesLike]]
  ): string;
  encodeFunctionData(
    functionFragment: "pendingDuration",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pendingOf",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "release",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "reserveOf",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "scatter",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setBlacklist",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setPendingDuration",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setThreshold",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "thresholdOf", values: [string]): string;
  encodeFunctionData(functionFragment: "weth", values?: undefined): string;
  encodeFunctionData(functionFragment: "withdraw", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "withdrawFor",
    values: [string, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "allInstruments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allInstrumentsLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "config", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "depositFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fundFlowOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "gather", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAllInstruments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "handler", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "indexOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "instrumentInitData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBlacklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "launch", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pendingOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "release", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "reserveOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "scatter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setBlacklist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPendingDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "thresholdOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "weth", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawFor",
    data: BytesLike
  ): Result;

  events: {
    "Blacklist(address,bool)": EventFragment;
    "Deposit(address,address,uint256)": EventFragment;
    "Gather(address,address,address,uint32,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "NewInstrument(bytes32,address,address,address,string,uint256)": EventFragment;
    "Scatter(address,address,address,uint32,uint256)": EventFragment;
    "SetPendingDuration(uint256)": EventFragment;
    "SetThreshold(address,uint256)": EventFragment;
    "UpdatePending(address,address,(uint32,bool,uint96,uint120))": EventFragment;
    "Withdraw(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Blacklist"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Gather"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewInstrument"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Scatter"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetPendingDuration"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetThreshold"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatePending"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
}

export interface BlacklistEventObject {
  trader: string;
  banned: boolean;
}
export type BlacklistEvent = TypedEvent<
  [string, boolean],
  BlacklistEventObject
>;

export type BlacklistEventFilter = TypedEventFilter<BlacklistEvent>;

export interface DepositEventObject {
  quote: string;
  trader: string;
  quantity: BigNumber;
}
export type DepositEvent = TypedEvent<
  [string, string, BigNumber],
  DepositEventObject
>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface GatherEventObject {
  quote: string;
  trader: string;
  instrument: string;
  expiry: number;
  quantity: BigNumber;
}
export type GatherEvent = TypedEvent<
  [string, string, string, number, BigNumber],
  GatherEventObject
>;

export type GatherEventFilter = TypedEventFilter<GatherEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface NewInstrumentEventObject {
  index: string;
  instrument: string;
  base: string;
  quote: string;
  symbol: string;
  total: BigNumber;
}
export type NewInstrumentEvent = TypedEvent<
  [string, string, string, string, string, BigNumber],
  NewInstrumentEventObject
>;

export type NewInstrumentEventFilter = TypedEventFilter<NewInstrumentEvent>;

export interface ScatterEventObject {
  quote: string;
  trader: string;
  instrument: string;
  expiry: number;
  quantity: BigNumber;
}
export type ScatterEvent = TypedEvent<
  [string, string, string, number, BigNumber],
  ScatterEventObject
>;

export type ScatterEventFilter = TypedEventFilter<ScatterEvent>;

export interface SetPendingDurationEventObject {
  duration: BigNumber;
}
export type SetPendingDurationEvent = TypedEvent<
  [BigNumber],
  SetPendingDurationEventObject
>;

export type SetPendingDurationEventFilter =
  TypedEventFilter<SetPendingDurationEvent>;

export interface SetThresholdEventObject {
  quote: string;
  threshold: BigNumber;
}
export type SetThresholdEvent = TypedEvent<
  [string, BigNumber],
  SetThresholdEventObject
>;

export type SetThresholdEventFilter = TypedEventFilter<SetThresholdEvent>;

export interface UpdatePendingEventObject {
  quote: string;
  trader: string;
  pending: PendingStructOutput;
}
export type UpdatePendingEvent = TypedEvent<
  [string, string, PendingStructOutput],
  UpdatePendingEventObject
>;

export type UpdatePendingEventFilter = TypedEventFilter<UpdatePendingEvent>;

export interface WithdrawEventObject {
  quote: string;
  trader: string;
  quantity: BigNumber;
}
export type WithdrawEvent = TypedEvent<
  [string, string, BigNumber],
  WithdrawEventObject
>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface Gate extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GateInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    allInstruments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    allInstrumentsLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    config(overrides?: CallOverrides): Promise<[string]>;

    deposit(
      arg: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    depositFor(
      trader: string,
      arg: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    fundFlowOf(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<[FundFlowStructOutput] & { fundFlow: FundFlowStructOutput }>;

    gather(
      quote: string,
      trader: string,
      expiry: BigNumberish,
      quantity: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getAllInstruments(overrides?: CallOverrides): Promise<[string[]]>;

    handler(overrides?: CallOverrides): Promise<[string]>;

    indexOf(
      instrument: string,
      overrides?: CallOverrides
    ): Promise<[string] & { index: string }>;

    initialize(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    instrumentInitData(overrides?: CallOverrides): Promise<[string]>;

    isBlacklisted(user: string, overrides?: CallOverrides): Promise<[boolean]>;

    launch(
      mtype: string,
      instrument: string,
      data: BytesLike,
      addArgs: [BytesLike, BytesLike],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    pendingDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    pendingOf(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<[PendingStructOutput] & { pending: PendingStructOutput }>;

    release(
      quote: string,
      trader: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    reserveOf(
      quote: string,
      user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { balance: BigNumber }>;

    scatter(
      quote: string,
      trader: string,
      expiry: BigNumberish,
      quantity: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setBlacklist(
      trader: string,
      banned: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setPendingDuration(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setThreshold(
      quote: string,
      threshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    thresholdOf(
      quote: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { threshold: BigNumber }>;

    weth(overrides?: CallOverrides): Promise<[string]>;

    withdraw(
      arg: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    withdrawFor(
      trader: string,
      arg: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  allInstruments(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  allInstrumentsLength(overrides?: CallOverrides): Promise<BigNumber>;

  config(overrides?: CallOverrides): Promise<string>;

  deposit(
    arg: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  depositFor(
    trader: string,
    arg: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  fundFlowOf(
    quote: string,
    trader: string,
    overrides?: CallOverrides
  ): Promise<FundFlowStructOutput>;

  gather(
    quote: string,
    trader: string,
    expiry: BigNumberish,
    quantity: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getAllInstruments(overrides?: CallOverrides): Promise<string[]>;

  handler(overrides?: CallOverrides): Promise<string>;

  indexOf(instrument: string, overrides?: CallOverrides): Promise<string>;

  initialize(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  instrumentInitData(overrides?: CallOverrides): Promise<string>;

  isBlacklisted(user: string, overrides?: CallOverrides): Promise<boolean>;

  launch(
    mtype: string,
    instrument: string,
    data: BytesLike,
    addArgs: [BytesLike, BytesLike],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  pendingDuration(overrides?: CallOverrides): Promise<BigNumber>;

  pendingOf(
    quote: string,
    trader: string,
    overrides?: CallOverrides
  ): Promise<PendingStructOutput>;

  release(
    quote: string,
    trader: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  reserveOf(
    quote: string,
    user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  scatter(
    quote: string,
    trader: string,
    expiry: BigNumberish,
    quantity: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setBlacklist(
    trader: string,
    banned: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setPendingDuration(
    duration: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setThreshold(
    quote: string,
    threshold: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  thresholdOf(quote: string, overrides?: CallOverrides): Promise<BigNumber>;

  weth(overrides?: CallOverrides): Promise<string>;

  withdraw(
    arg: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  withdrawFor(
    trader: string,
    arg: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    allInstruments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    allInstrumentsLength(overrides?: CallOverrides): Promise<BigNumber>;

    config(overrides?: CallOverrides): Promise<string>;

    deposit(arg: BytesLike, overrides?: CallOverrides): Promise<void>;

    depositFor(
      trader: string,
      arg: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    fundFlowOf(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<FundFlowStructOutput>;

    gather(
      quote: string,
      trader: string,
      expiry: BigNumberish,
      quantity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    getAllInstruments(overrides?: CallOverrides): Promise<string[]>;

    handler(overrides?: CallOverrides): Promise<string>;

    indexOf(instrument: string, overrides?: CallOverrides): Promise<string>;

    initialize(overrides?: CallOverrides): Promise<void>;

    instrumentInitData(overrides?: CallOverrides): Promise<string>;

    isBlacklisted(user: string, overrides?: CallOverrides): Promise<boolean>;

    launch(
      mtype: string,
      instrument: string,
      data: BytesLike,
      addArgs: [BytesLike, BytesLike],
      overrides?: CallOverrides
    ): Promise<
      [number, number, RangeStructOutput] & {
        tickLower: number;
        tickUpper: number;
        range: RangeStructOutput;
      }
    >;

    pendingDuration(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOf(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<PendingStructOutput>;

    release(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<void>;

    reserveOf(
      quote: string,
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scatter(
      quote: string,
      trader: string,
      expiry: BigNumberish,
      quantity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setBlacklist(
      trader: string,
      banned: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setPendingDuration(
      duration: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setThreshold(
      quote: string,
      threshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    thresholdOf(quote: string, overrides?: CallOverrides): Promise<BigNumber>;

    weth(overrides?: CallOverrides): Promise<string>;

    withdraw(arg: BytesLike, overrides?: CallOverrides): Promise<void>;

    withdrawFor(
      trader: string,
      arg: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "Blacklist(address,bool)"(
      trader?: string | null,
      banned?: null
    ): BlacklistEventFilter;
    Blacklist(trader?: string | null, banned?: null): BlacklistEventFilter;

    "Deposit(address,address,uint256)"(
      quote?: string | null,
      trader?: string | null,
      quantity?: null
    ): DepositEventFilter;
    Deposit(
      quote?: string | null,
      trader?: string | null,
      quantity?: null
    ): DepositEventFilter;

    "Gather(address,address,address,uint32,uint256)"(
      quote?: string | null,
      trader?: string | null,
      instrument?: string | null,
      expiry?: null,
      quantity?: null
    ): GatherEventFilter;
    Gather(
      quote?: string | null,
      trader?: string | null,
      instrument?: string | null,
      expiry?: null,
      quantity?: null
    ): GatherEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "NewInstrument(bytes32,address,address,address,string,uint256)"(
      index?: null,
      instrument?: null,
      base?: null,
      quote?: null,
      symbol?: null,
      total?: null
    ): NewInstrumentEventFilter;
    NewInstrument(
      index?: null,
      instrument?: null,
      base?: null,
      quote?: null,
      symbol?: null,
      total?: null
    ): NewInstrumentEventFilter;

    "Scatter(address,address,address,uint32,uint256)"(
      quote?: string | null,
      trader?: string | null,
      instrument?: string | null,
      expiry?: null,
      quantity?: null
    ): ScatterEventFilter;
    Scatter(
      quote?: string | null,
      trader?: string | null,
      instrument?: string | null,
      expiry?: null,
      quantity?: null
    ): ScatterEventFilter;

    "SetPendingDuration(uint256)"(
      duration?: null
    ): SetPendingDurationEventFilter;
    SetPendingDuration(duration?: null): SetPendingDurationEventFilter;

    "SetThreshold(address,uint256)"(
      quote?: string | null,
      threshold?: null
    ): SetThresholdEventFilter;
    SetThreshold(
      quote?: string | null,
      threshold?: null
    ): SetThresholdEventFilter;

    "UpdatePending(address,address,(uint32,bool,uint96,uint120))"(
      quote?: string | null,
      trader?: string | null,
      pending?: null
    ): UpdatePendingEventFilter;
    UpdatePending(
      quote?: string | null,
      trader?: string | null,
      pending?: null
    ): UpdatePendingEventFilter;

    "Withdraw(address,address,uint256)"(
      quote?: string | null,
      trader?: string | null,
      quantity?: null
    ): WithdrawEventFilter;
    Withdraw(
      quote?: string | null,
      trader?: string | null,
      quantity?: null
    ): WithdrawEventFilter;
  };

  estimateGas: {
    allInstruments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allInstrumentsLength(overrides?: CallOverrides): Promise<BigNumber>;

    config(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      arg: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    depositFor(
      trader: string,
      arg: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    fundFlowOf(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    gather(
      quote: string,
      trader: string,
      expiry: BigNumberish,
      quantity: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getAllInstruments(overrides?: CallOverrides): Promise<BigNumber>;

    handler(overrides?: CallOverrides): Promise<BigNumber>;

    indexOf(instrument: string, overrides?: CallOverrides): Promise<BigNumber>;

    initialize(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    instrumentInitData(overrides?: CallOverrides): Promise<BigNumber>;

    isBlacklisted(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    launch(
      mtype: string,
      instrument: string,
      data: BytesLike,
      addArgs: [BytesLike, BytesLike],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    pendingDuration(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOf(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    release(
      quote: string,
      trader: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    reserveOf(
      quote: string,
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scatter(
      quote: string,
      trader: string,
      expiry: BigNumberish,
      quantity: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setBlacklist(
      trader: string,
      banned: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setPendingDuration(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setThreshold(
      quote: string,
      threshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    thresholdOf(quote: string, overrides?: CallOverrides): Promise<BigNumber>;

    weth(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      arg: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    withdrawFor(
      trader: string,
      arg: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    allInstruments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allInstrumentsLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    config(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      arg: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    depositFor(
      trader: string,
      arg: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    fundFlowOf(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    gather(
      quote: string,
      trader: string,
      expiry: BigNumberish,
      quantity: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getAllInstruments(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    handler(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    indexOf(
      instrument: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    instrumentInitData(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBlacklisted(
      user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    launch(
      mtype: string,
      instrument: string,
      data: BytesLike,
      addArgs: [BytesLike, BytesLike],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    pendingDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOf(
      quote: string,
      trader: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    release(
      quote: string,
      trader: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    reserveOf(
      quote: string,
      user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    scatter(
      quote: string,
      trader: string,
      expiry: BigNumberish,
      quantity: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setBlacklist(
      trader: string,
      banned: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setPendingDuration(
      duration: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setThreshold(
      quote: string,
      threshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    thresholdOf(
      quote: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    weth(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      arg: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    withdrawFor(
      trader: string,
      arg: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
